# 4.2.6.1 Working with events

{% hint style="success" %}
All technical concepts related to Events are collated in this [README](https://github.com/opencrvs/opencrvs-core/blob/develop/packages/commons/src/events/README.md)
{% endhint %}

Using concepts introduced in the README above, along with an understanding of the [metadata](https://github.com/opencrvs/opencrvs-core/blob/develop/packages/commons/src/events/EventMetadata.ts) properties associated with an event, you can configure any type of event you like in OpenCRVS.



## Serving events to OpenCRVS Core

Events that are configured in your countryconfig service are made available to core from [this](https://github.com/opencrvs/opencrvs-countryconfig/blob/0fc50a9d21d2c7525e5b8e3b8f1cd7c0ca7a7328/src/api/custom-event/handler.ts#L23) endpoint.

Examples for [birth](https://github.com/opencrvs/opencrvs-countryconfig/blob/develop/src/form/v2/birth/index.ts) and [death](https://github.com/opencrvs/opencrvs-countryconfig/blob/develop/src/form/v2/death/index.ts) are provided, along with an example [tennis club membership](https://github.com/opencrvs/opencrvs-countryconfig/blob/develop/src/form/tennis-club-membership.ts) event (just to demonstrate the flexibility of OpenCRVS as a general registry showing usage of more form components).

Your first configuration is probably going to be: to comment out the tennis club membership example event from this handler and any mention of the `tennis-club-membership` Event ID from associated user scopes in the [roles.ts](https://roles.tshttps/github.com/opencrvs/opencrvs-countryconfig/blob/0fc50a9d21d2c7525e5b8e3b8f1cd7c0ca7a7328/src/data-seeding/roles/roles.ts#L29) file.



## Configuring a new v2 event with `EventConfigInput`

In OpenCRVS ≥ 1.9, each event in your **country configuration** is defined in the `src/form/v2` directory.&#x20;

The central building block is an **`EventConfigInput`** object – a Zod-validated input shape for the `EventConfig` type in `opencrvs-core` (`packages/commons/src/events`). This object captures, for a single event:

* the **event identifier** (critical)
* the **declaration form** (what users fill in to declare the event)
* the **search form** (the fields available in _Search for a record_)
* the **summary configuration** (what you see in the record “card” when you click an item in a workqueue or search result)&#x20;
* the **title, template**, **label**, and **dateOfEvent** field mapping

Core reads an array of these configs from your countryconfig `/custom-event` endpoint and uses them to power the event flows described in the events README

***

### Where v2 event configs live

All v2 events are defined under:

```
src/form/v2/
```

> ✅ When adding a new v2 event, **only** work inside `src/form/v2`.\
> Ignore the legacy `src/form/<event>` directories used in v1.8 – the v2 engine is completely separate.

The **birth** event at `src/form/v2/birth/index.ts` is your reference implementation for how to construct an `EventConfigInput` for an event.&#x20;

### Configure the declaration form (inside `EventConfigInput`)

The **declaration form** section&#x20;

### Configure the search form

Next, configure the **search form** portion of `EventConfigInput`, which controls the **“Search for a record”** UI for this event.

Conceptually, the search form is:

* A set of **search fields** (e.g. name, registration number, event date range, place).
* Grouped into **basic / advanced** panels if desired.
* Mapped to backend query parameters or index fields.

Typical design:

* **Quick search**
  * A small set of highly discriminative fields (e.g. registration number, national ID, or name + date of event).
* **Advanced search**
  * Additional filters (location, informant type, status, office, etc.).

**Process:**

1. Decide which fields users genuinely need to search on for this event.
   * Start from what is actually stored and indexed in Core.
2. Re-use existing field definitions where it makes sense (e.g. same labels and message IDs) but remember:
   * Search fields typically don’t need the heavy validation of the declaration form.
   * They do need to map reliably to backend query fields.
3. Define the search form structure for the event, using whichever v2 helpers `birth` uses for its search config.

In the `EventConfigInput`:

```ts
export const yourEventConfig: EventConfigInput = {
  // ...
  searchForm: buildSearchForm(),           // fields & groups used in “Search for a record”
  // ...
}
```

When **Core** loads this config, it uses it to render the search UI for that event and construct the query payload for the _Search for a record_ flow.

***

### Configure the summary (workqueue / search result card)

Finally, configure the **summary** portion of `EventConfigInput` – the little “card” you see when you:

* click a record in a **workqueue**, or
* select a record from the **search results** and view its details. [documentation.opencrvs.org](https://documentation.opencrvs.org/product-specifications/core-functions?utm_source=chatgpt.com)

This summary usually shows:

* key identity info (names)
* event specifics (event date, place)
* registration details (registration number, office)
* current status (Registered, Requires updates, etc.)

**Process:**

1. Identify the _minimal_ set of fields that allow a registrar to:
   * confirm they have the right record, and
   * quickly assess its status.
2. Map each summary item to an underlying field path or handlebar (often the same as used for certificates and FHIR mappings).
3. Arrange them in a sensible order and grouping (e.g. top line: name and registration number; second line: event date and place; third line: status and office).

In the `EventConfigInput`:

```ts
export const yourEventConfig: EventConfigInput = {
  // ...
  summary: buildSummaryConfig(),           // fields shown in record “card”
}
```

When Core renders a **workqueue** or **search results**, it uses this summary config to build the compact record view.



### Testing your new event end-to-end

After wiring everything up:

1. **Run OpenCRVS Core + your countryconfig** (as per usual dev setup).
2. Hit the `/custom-event` endpoint and confirm:
   * Your new event appears with the correct `eventType` / key / version.
   * `declarationForm`, `searchForm` and `summary` sections are present in the payload.
3. In the UI:
   * **Declare** the new event and walk through all sections/groups:
     * required/optional fields behave as expected
     * conditionals and validation work
   * **Register** the event, **reviewing, printing** and **correcting** it.  Verify forms / views / certificates behave as expected.&#x20;
   * Use **Search for a record**:
     * confirm your new search form appears,
     * filters apply correctly and return the expected records.
   * Click a result / workqueue item:
     * confirm the **summary card** matches your configuration.

***

#### Further reading:

An explanation regarding how events are stored in the [database](https://github.com/opencrvs/opencrvs-core/blob/develop/packages/events/DATABASE.md).

#### OpenCRVS API Documentation

[https://api.opencrvs.org/develop/events/index.html](https://api.opencrvs.org/develop/events/index.html)
